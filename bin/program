#!/usr/bin/env bash
#export

GIT_REPO_URL="git@github.com:ryanniehaus/open_source_package_builder.git"

pushd "$TEMP_APP_DIR" > /dev/null

#make sure the ssh-agent is running in the background
eval "$(ssh-agent -s)"

#add the ssh key to the agent
git config --global user.email "ryan.niehaus@gmail.com"
git config --global user.name "Ryan Niehaus"
git config --global credential.https://github.com.username ryanniehaus
git config --global push.default simple

echo downloading $(dataURLFromCloudinary.py id_rsa)
wget --no-cache $(dataURLFromCloudinary.py id_rsa) &> /dev/null
echo downloading $(dataURLFromCloudinary.py id_rsa.pub)
wget --no-cache $(dataURLFromCloudinary.py id_rsa.pub) &> /dev/null

chmod og-rwx,u+rw id_rsa*

ln -s ~/.apt/usr/share/tcltk/tcl8.6 ~/.apt/usr/lib/tcl8.6

echo "#!/usr/bin/env expect" > `pwd`"/ps.sh"
echo "spawn ssh-add id_rsa" >> `pwd`"/ps.sh"
echo "expect \"Enter passphrase for id_rsa:\"" >> `pwd`"/ps.sh"
echo "send \"$RSA_PASSPHRASE\n\";" >> `pwd`"/ps.sh"
echo "interact" >> `pwd`"/ps.sh"
echo >> `pwd`"/ps.sh"
chmod go-rwx,u+rx `pwd`"/ps.sh"
`pwd`"/ps.sh"

ssh -q -oStrictHostKeyChecking=no git@github.com exit
echo ssh check returned $?

#get the open source tracking table from persistent storage
echo downloading $(dataURLFromCloudinary.py openSourceTracker.csv)
wget --no-cache $(dataURLFromCloudinary.py openSourceTracker.csv) &> /dev/null

# if the tracker doesn't exist, create with defaults
if [ ! -f openSourceTracker.csv ]
then
	echo "openSourceTracker.csv Not here, creating... "
	echo "projectName,branchesURL" > openSourceTracker.csv
fi

# make sure the table has unix line endings
dos2unix openSourceTracker.csv &> /dev/null

# grab only the contents of the tracker table, not the header
tail -n+2 openSourceTracker.csv > openSourceTrackerWithoutHeader.csv
# read each line of the tracker table contents
> "ARCHIVES.txt"
while IFS= read tempLine
do
	#grab the relevant fields from the tracker table
	projectName=$(echo "$tempLine" | cut -f 1 -d ",")
	branchesURL=$(echo "$tempLine" | cut -f 2 -d "," | sed 's|[/]\+$||')

	# grab the branches url in the project repo
	wget "$branchesURL" -O "$projectName.html" &> /dev/null
	# convert the dir listing to unix format, for easy parsing
	dos2unix "$projectName.html" &> /dev/null
	# build the archive lists from the dir listing links
	sed -n 's/.*href="\([^"]*\).*/\1/p' "$projectName.html" \
		| sed 's|^'"$branchesURL"'[/]*||;s|[/]\+$||' \
		| grep -E "^$projectName-[0-9]+[.][0-9]+[.][.0-9a-zA-Z~-]+[.]tar[.]gz$" \
		| sed 's|^\('"$projectName"'-\)\([0-9]\+[.][0-9]\+[.][.0-9a-zA-Z~-]\+\)\([.]tar[.]gz\)$|'"$projectName"',\2,'"$branchesURL"'/\1\2\3|g' >> "ARCHIVES.txt"

	# some the branches may have subfolders for versions, grab those subdirs
	sed -n 's/.*href="\([^"]*\).*/\1/p' "$projectName.html" | sed 's|^'"$branchesURL"'[/]*||;s|[/]\+$||' | grep -E "^[0-9]+[.][0-9]+[.][.0-9a-zA-Z~-]+" > "$projectName.SUBDIRS.txt"
	# loop through each of the branch version subdirectories
	while IFS= read tempSubdir
	do
		#grab the subdirectory listing url in the project repo
		wget "$branchesURL"/"$tempSubdir" -O "$projectName.html" &> /dev/null
		# convert the subdir listing to unix format, for easy parsing
		dos2unix "$projectName.html" &> /dev/null
		# add to the archive lists from the subdir listing links
		sed -n 's/.*href="\([^"]*\).*/\1/p' "$projectName.html" \
			| sed 's|^'"$branchesURL/$tempSubdir"'[/]*||;s|[/]\+$||' \
			| grep -E "^$projectName-[0-9]+[.][0-9]+[.][.0-9a-zA-Z~-]+[.]tar[.]gz$" \
			| sed 's|^\('"$projectName"'-\)\([0-9]\+[.][0-9]\+[.][.0-9a-zA-Z~-]\+\)\([.]tar[.]gz\)$|'"$projectName"',\2,'"$branchesURL"'/'"$tempSubdir"'/\1\2\3|g' >> "ARCHIVES.txt"
	done < "$projectName.SUBDIRS.txt"

	#remove files not using anymore
	rm -f "$projectName.SUBDIRS.txt"
	rm -f "$projectName.html"
done < openSourceTrackerWithoutHeader.csv
rm -f openSourceTrackerWithoutHeader.csv

sort -t"," -d -k1,1 -V -k2,2 "ARCHIVES.txt"
cat "ARCHIVES.txt"

git clone "$GIT_REPO_URL" ospb

if [ -d ospb ]
then
	if [ ! -f ospb/archives_to_process ]
	then
		> ospb/archives_to_process
	fi

	if [ ! -f ospb/archives_successfully_processed ]
	then
		> ospb/archives_successfully_processed
	fi

	if [ ! -f ospb/archives_blacklisted ]
	then
		> ospb/archives_blacklisted
	fi

	while IFS= read archiveLine
	do
		projectNameAndVersion=$(echo "$archiveLine" | sed 's|^\([^,]\+\),\([^,]\+\),\([^,]\+\)$|\1,\2,|')
		alreadyProcessed=$(grep -E "^$projectNameAndVersion" ospb/archives_successfully_processed)
		alreadyMarkedForProcessing=$(grep -E "^$projectNameAndVersion" ospb/archives_to_process)
		alreadyBlacklisted=$(grep -E "^$projectNameAndVersion" ospb/archives_blacklisted)
		projectName=$(echo "$projectNameAndVersion" | cut -f 1 -d ",")
		projectVersion=$(echo "$projectNameAndVersion" | cut -f 2 -d ",")

		if [ "$alreadyProcessed" == "" -a "$alreadyMarkedForProcessing" == "" -a "$alreadyBlacklisted" == "" ]
		then
			echo ADDING $(echo "$archiveLine" | cut -f 1 -d ",") VERSION $(echo "$archiveLine" | cut -f 2 -d ",") TO LIST
			echo "$archiveLine" > ospb/archives_to_process
			
			pushd ospb > /dev/null
			git add -v archives_to_process
			git add -v archives_successfully_processed
			git add -v archives_blacklisted
			git commit -m "heroku-automated-project-analysis"
			git push
			
			branchExists=$(git branch -r --list | sed 's|^[ \t]\+||;s|[ \t]\+$||' | grep origin/RELEASE_"$projectName"v"$projectVersion")
			
			if [ "$branchExists" == "" ]
			then
				# create branch
				git branch -v origin/RELEASE_"$projectName"v"$projectVersion"
			else
				# merge master to branch
				git checkout testing
				git merge --commit master -m "merging latest master to branch using heroku-automated-project-analysis"
				git push
			fi
			popd > /dev/null
		fi
	done < "ARCHIVES.txt"
fi

# convert the tracker table back to dos line endings
unix2dos openSourceTracker.csv &> /dev/null

# upload the tracker table back to persistent storage
echo uploading $(dataURLFromCloudinary.py openSourceTracker.csv)
uploadDataToCloudinary.py openSourceTracker.csv openSourceTracker.csv

popd > /dev/null


